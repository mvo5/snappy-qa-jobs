#!/usr/bin/env python3

import argparse
import json
import os
import subprocess
import sys
import time

ERROR_TYPE = 'Error'
DEBUG_TYPE = 'Debug'
WARN_TYPE = 'WARNING:'
FAILED_RESULT = 'Failed'

EXEC_VERBS = ['Preparing', 'Executing', 'Restoring']
INFO_TYPES = [ERROR_TYPE, DEBUG_TYPE, WARN_TYPE]
OPERATIONS = ['Rebooting', 'Discarding', 'Allocating', 'Waiting', 'Allocated', 'Connecting', 'Connected', 'Sending']
RESULTS = ['Successful', 'Aborted', 'Failed']


class Action:
    def __init__(self, verb, task, date, time):
        self.verb = verb
        self.time = time
        self.date = date
        self.task = task

    def __repr__(self):
        return str(self.__dict__())

    def __dict__(self):
        return {'type': 'action', 'date': self.date, 'time': self.time, 'verb': self.verb, 'task': self.task}


class Result:
    def __init__(self, result_type, level, number, date, time, detail):
        self.result_type = result_type
        self.level = level
        self.number = number
        self.time = time
        self.date = date
        self.detail = detail

    def __repr__(self):
        return str(self.__dict__())

    def __dict__(self):
        prepared_detail = None
        if self.detail:
            prepared_detail = self.detail.__dict__()
        return {'type': 'result', 'date': self.date, 'time': self.time, 'result_type': self.result_type, 'level': self.level,  'number': self.number, 'detail': prepared_detail}


class Info:
    def __init__(self, info_type, verb, task, extra, date, time, detail):
        self.info_type = info_type
        self.verb = verb
        self.time = time
        self.date = date
        self.task = task
        self.extra = extra 
        self.detail = detail

    def __repr__(self):
        return str(self.__dict__())

    def __dict__(self):
        prepared_detail = None
        if self.detail:
            prepared_detail = self.detail.__dict__()
        return {'type': 'info', 'date': self.date, 'time': self.time, 'info_type': self.info_type, 'verb': self.verb, 'task': self.task, 'extra': self.extra, 'detail': prepared_detail}


class Detail:
    def __init__(self, lines_limit, lines):
        self.lines_limit = lines_limit
        self.lines = lines

    def __repr__(self):
        return str(self.__dict__())

    def __dict__(self):
        return {'type': 'detail', 'lines': self.lines[-1*self.lines_limit:]}


class Operation:
    def __init__(self, verb, task, extra, date, time):
        self.verb = verb
        self.time = time
        self.extra = extra
        self.date = date
        self.task = task

    def __repr__(self):
        return str(self.__dict__())

    def __dict__(self):
        return {'type': 'operation', 'date': self.date, 'time': self.time, 'verb': self.verb, 'task': self.task, 'extra': self.extra}


class LogReader:
    def __init__(self, filepath, output_type, lines_limit):
        self.filepath = filepath
        self.output_type = output_type
        self.lines_limit = lines_limit
        self.lines = []
        self.iter = 0
        self.full_log = []

    def __repr__(self):
        return str(self.__dict__())

    def __dict__(self):
        return {'full_log': self.full_log}

    def print_log(self):
        for entry in self.full_log:
            print(entry)

    def export_log(self, filepath):
        prepared_log = []
        for item in self.full_log:
            prepared_log.append(item.__dict__())
        with open(filepath, 'w') as json_file:
            json.dump(prepared_log, json_file)

    def _next_line(self):
        self.iter = self.iter + 1
        return self.lines[self.iter-1]

    def check_log_exists(self):
        return os.path.exists(self.filepath)

    def read_spread_log(self):
        with open(self.filepath) as fp:
            self.lines = fp.readlines()
            self.iter = 0
            while self.iter < len(self.lines):
                line = self._next_line()
                if self._match_task(line):
                    action = self._get_action(line)
                    if action:
                        #print(action)
                        self.full_log.append(action)
                    continue

                if self._match_info(line):
                    info = self._get_info(line)
                    if info:
                        #print(info)
                        self.full_log.append(info)
                    continue

                if self._match_operation(line): 
                    operation = self._get_operation(line)
                    if operation:
                        #print(operation)
                        self.full_log.append(operation)
                    continue

                if self._match_result(line):
                    result = self._get_result(line)
                    if result:
                        #print(result)
                        self.full_log.append(result)
                    continue

    def _match_info(self, line):
        parts = line.split(' ')
        return len(parts) > 3 and parts[2] in INFO_TYPES

    def _match_task(self, line):
        parts = line.split(' ')
        return len(parts) > 2 and parts[2] in EXEC_VERBS

    def _match_operation(self, line):
        parts = line.split(' ')
        return len(parts) > 2 and parts[2] in OPERATIONS

    def _match_result(self, line):
        parts = line.split(' ')
        return len(parts) > 2 and parts[2] in RESULTS

    def _get_detail(self):
        initial_iter = self.iter
        while self.iter < len(self.lines):
            line = self._next_line()
            if self._match_task(line) or self._match_info(line) or self._match_operation(line) or self._match_result(line):
                break
        self.iter = self.iter - 1
        return Detail(self.lines_limit, self.lines[initial_iter:self.iter])

    def _get_info(self, line):
        parts = line.split(' ')
        if len(parts) < 3:
            print(parts)
            return None 
        date = parts[0]
        time = parts[1]
        info_type = parts[2]
        verb = None
        task = None
        if info_type == WARN_TYPE:
            info_type = info_type.split(':')[0]
            verb = None
            task = None
            extra = ' '.join(parts[3:])
        elif info_type == ERROR_TYPE:
            verb = parts[3]
            task = parts[4]
            extra = None
        elif info_type == DEBUG_TYPE:
            verb = parts[3]
            task = parts[4]
            extra = None
        else:
            print('Detail type not recognized: {}'.format(info_type))

        detail = self._get_detail()
        return Info(info_type, verb, task, extra, date, time, detail)

    def _get_result(self, line):
        parts = line.split(' ')
        if len(parts) < 3:
            print(parts)
            return None
        date = parts[0]
        time = parts[1]
        result_type = parts[2]
        level = parts[3].split(':')[0]
        number = parts[4]

        if result_type == FAILED_RESULT:
            detail = self._get_detail()
        else:
            detail = None

        return Result(result_type, level, number.strip(), date, time, detail)

    def _get_action(self, line):
        parts = line.split(' ')
        if len(parts) < 3:
            return None
        date = parts[0]
        time = parts[1]
        verb = parts[2]
        if verb in EXEC_VERBS:
            task = parts[3]
            return Action(verb, task.split('...')[0], date, time)

        return None

    def _get_operation(self, line):
        parts = line.split(' ')
        if len(parts) < 3:
            return None
        date = parts[0]
        time = parts[1]
        verb = parts[2]
        task = None
        if verb in OPERATIONS:
            extra = ' '.join(parts[3:])
            return Operation(verb, task, extra, date, time)

        return None


def _make_parser():
    # type: () -> argparse.ArgumentParser
    parser = argparse.ArgumentParser(
        description="""
Analyze the spread log and generates a file with a standarized output
"""
    )
    parser.add_argument(
        "-c",
        "--cut",
        metavar="N",
        type=int,
        default=100,
        help="maximun number of lines for logs on errors and debug sections",
    )
    parser.add_argument(
        "-f",
        "--format",
        type=str,
        default="json",
        choices=['json'],
        help="format for the output",
    )
    parser.add_argument(
        "-q",
        "--quiet",
        action="store_true",
        default=False,
        help="refrain from printing any output",
    )
    parser.add_argument(
        "-o",
        "--output",
        type=str,
        help="output file to save the result",
    )
    parser.add_argument(
        "logpath", metavar="PATH", help="path to the log to be analyzed"
    )
    return parser


def main():
    # type: () -> None
    parser = _make_parser()
    ns = parser.parse_args()
    # The command cannot be empty but it is difficult to express in argparse itself.
    if len(ns.logpath) == 0:
        parser.print_usage()
        parser.exit(0)
    
    reader = LogReader(ns.logpath, ns.format, ns.cut)
    if not reader.check_log_exists():
        print("Log not found")
        sys.exit(1)

    reader.read_spread_log()

    if ns.output:
        reader.export_log(ns.output)

    if not ns.quiet:
        reader.print_log()
    

if __name__ == "__main__":
    main()
